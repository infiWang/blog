<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>十二月二十三日</title>
      <link href="posts/2020/12/december-23rd.zh/"/>
      <url>posts/2020/12/december-23rd.zh/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">infi@infiSurfaceGo2 ~ &gt; date</span><br><span class="line"></span><br><span class="line">Wednesday, December 23, 2020 11:39:01 PM</span><br><span class="line"></span><br><span class="line">infi@infiSurfaceGo2 ~ &gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.infi.wang/pic/blog/december-23rd/heartlake-nightview.jpeg" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/december-23rd/heartlake-nightview.jpeg" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="心湖夜景"></p><p>&emsp;&emsp;去年此刻，我应该还在调整着这里的持续集成系统。整整一天前，我刚下课，和队友在图书馆会合。现在，我坐在宿舍楼下的自习室。敲下这行字的几十分钟后，咱就二十岁了。</p><span id="more"></span><h2 id="“岁岁除“"><a href="#“岁岁除“" class="headerlink" title="“岁岁除“"></a>“岁岁除“</h2><p>&emsp;&emsp;“年”，指地球公转一周所用的时间。“岁”，指以年为单位的、某个事物存在的时间。</p><p>&emsp;&emsp;咱不太喜欢写东西，但很明显，今天例外。所以让我提个问题：这个生日很特别吗？</p><p>&emsp;&emsp;我们先探讨一下时间的度量。任何量的评判都免不了对比，时间也不例外。我们用一个昼夜或一年的一部分来定义一天；相似地，我们也用原子震荡一定次数所花的时间定义一秒。改变用来定义的参照，时间仍然是时间，不过是做了线性变换而已，某种程度上还不如说是我们的定义眼光狭隘、有失偏颇。古罗马历法的一年只有十个月, 各式基于月相的历法也和公历大相径庭。如果把一年的长度缩短三百六十五倍，每一天都可以是你的生日; 把一秒的长度拉伸千万倍，“则天地曾不能以一瞬”……</p><p>&emsp;&emsp;在小学后，仪式感早已没有那么强烈了。但既然ddl战士的我还是在今天写下了上面的话，很明显，今年我的答案是肯定的。在一岁中，我们经历了许多：和朋友的欢笑，席卷全球的瘟疫，为自己的未来所做的奋斗，以及自己崭新的大学生活。尤其是最后一者，我并不满意，但又没有做出多少改变。</p><p>&emsp;&emsp;继续讨论之前的问题。为什么一天、一年的定义是现在这样的？答案很简单：日落日出，人们在休息后开始了不一样的活动；四季更迭，人们得以创造不一样的耕耘。新的开始决不是什么魔法，不愿做出改变的人无论迎来多少个明天都不会有所行动，不愿付诸实践的人就算整日提出设想也不会有新的收获。关键的部分是对事物的刷新：一晚的休息让我们又充满了动力，四季的更替让万物无时无刻不在变化之中。而当另一个相似却又崭新的回合来临时，一次反思显得弥足珍贵。我们活在熵增的世界，切莫把自己困在一成不变的热寂之中。</p><h2 id="十二月二十三日"><a href="#十二月二十三日" class="headerlink" title="十二月二十三日"></a>十二月二十三日</h2><p>&emsp;&emsp;三年前的十二月二十三日，心理咨询方才结束不久。回家的路上，我看着朋友的游戏直播，想起了之前联机时的欢乐时光。</p><p>&emsp;&emsp;两年前的的十二月二十三日，我刚刚进入梦乡。那是复学的第一个学期，一切都显得陌生、困难而又充满可能。</p><p>&emsp;&emsp;去年此刻，我调好了这里的持续集成系统，在社交媒体上展示的时候还开玩笑是给第十九年的自己的礼物。</p><p>&emsp;&emsp;整整一天前，我和队友在自习室赶着Java课的Project。并不喜欢这节课，但精神却又无比投入，“不知东方之既白”。</p><p>&emsp;&emsp;三小时前，教室里响起了清场广播。音乐是《回家》，和初中的清场广播一样；略带感伤却又无比悠扬。</p><p>&emsp;&emsp;两小时前，我翻阅着微积分和线性代数的讲义。下一周便是考试周，一定不能留下遗憾。</p><p>&emsp;&emsp;现在，我坐在宿舍楼下的自习室。敲下这行字的那一刻，咱已经二十岁了。</p>]]></content>
      
      
      <categories>
          
          <category> infi </category>
          
          <category> 中文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> infi </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彩虹六号：围攻 CGI与PCK声音解包指南</title>
      <link href="posts/2020/03/r6s-datamine-guide.zh/"/>
      <url>posts/2020/03/r6s-datamine-guide.zh/</url>
      
        <content type="html"><![CDATA[<p><strong>自Y5S3暗影之遗行动开始, 声音文件由PCK包变为了AnvilNext的Forge包. 本教程暂未对此做出更新</strong></p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/R6S.CGI.y5s1_opsunlock_bundle_dynamic.360P10FPS.gif" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/R6S.CGI.y5s1_opsunlock_bundle_dynamic.360P10FPS.gif" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="y5s1_opsunlock_bundle_dynamic"></p><p><strong>包本身和部分解包后的文件已上传至我的下载站, 持续更新</strong></p><p><a href="https://dl.infi.wang/R6SFiles/">infiDownloadSite/R6SFiles</a></p><p><strong>本教程需要您有一定计算机基础</strong></p><span id="more"></span><p>下载站也会对一些赛季限定内容进行归档, 让Siege的历史变得Unbreakable<a href="R6S%E7%AB%8B%E9%A1%B9%E4%B9%8B%E5%88%9D%E7%9A%84%E5%86%85%E9%83%A8%E4%BB%A3%E5%8F%B7">^1</a>!</p><p><strong>注意, 为了规避版权风险并减少无谓的破解，我永远不会归档二进制文件.</strong></p><h1 id="Operation-Breach-Out"><a href="#Operation-Breach-Out" class="headerlink" title="Operation Breach Out"></a>Operation Breach Out</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>*Rainbow Six Siege Operation Shifting Tides</p><p>*正在连接到服务器</p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/R6S.Y4S4.R2SI.MainMenu.Week1.jpg" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/R6S.Y4S4.R2SI.MainMenu.Week1.jpg" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="R2SI2020 Main Menu"></p><p>*通行证加载</p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/R6S.CGI.y4s4_overview.jpg" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/R6S.CGI.y4s4_overview.jpg" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="&quot;Welcome to the program. &quot;"></p><p>*通行证购买, 通行证关闭</p><p><i class="fas fa-history"></i> 通往国际邀请赛之路 58:32</p><span class='p cyan'><i class=fas fa-arrow-right> 对战已开始</i></span><p><img src="https://1734811051.rsc.cdn77.org/data/images/full/360859/rainbow-six-siege-road-to-si-2020-everything-you-need-to-know.jpg" class="lazyload placeholder" data-srcset="https://1734811051.rsc.cdn77.org/data/images/full/360859/rainbow-six-siege-road-to-si-2020-everything-you-need-to-know.jpg" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="Stadium Match Start"></p><div class="audio"><audio controls preload><source src='https://dl.infi.wang/R6SFiles/Sounds/Music/Map/Stadium/Theme.ogg' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><p>&emsp;&emsp;<del>当时听到这段BGM的时候差点没Ban对干员, 实在太ao听了</del></p><p>&emsp;&emsp;活动开始几天后发生了什么相信大家都知道. 很不巧, 加之自己的电脑显卡爆炸, 没有BGM听我要死了</p><p>&emsp;&emsp;所以我就开始研究怎么解包力，，，</p><h2 id="分析及解包"><a href="#分析及解包" class="headerlink" title="分析及解包"></a>分析及解包</h2><p>&emsp;&emsp;R6S的exe(PE)也许会有部分逻辑, 但太大了、没必要, 何况我也不是很懂binary逆向.  <del>而且通过观察黑盒判断黑盒内部逻辑不挺好玩的吗</del></p><p>&emsp;&emsp;R6S使用了Ubi自研的AnvilNext3.0引擎, 而用于存档的forge文件还和其它Anvil引擎游戏不太一样(好像FH也这个德性?) 所以材质、模型之类的东西我现在就不尝试了. (也许高考完会试试)</p><p>&emsp;&emsp;那剩下的只有CGI和声音了.</p><h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><p><strong>Ubi没有把声音打在bik里, 要么准备解pck声音包, 要么就享受无声世界罢.</strong></p><h4 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h4><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Player.m21_intro.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Player.m21_intro.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="Situation m21 Intro"></p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Player.y4s4_overview.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Player.y4s4_overview.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="R2SI2020 CGI"></p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Menu.Fileinfo.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Menu.Fileinfo.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="Bik Info"></p><p>&emsp;&emsp;如果你曾经研究过拆迁的文件结构, 会发现所有CGI其实都存储在RAD Video Tools打包的.bik视频文件里, 而文件本身则位于拆迁目录里的videos文件夹中. 文件没有加密, 具体编码封装工具据RAD VT报告称是Bink 2. 这样的bik文件去<a href="http://www.radgametools.com/">RAD官网</a>下载一套<a href="http://www.radgametools.com/bnkdown.htm">工具</a>就能打开. 在2018年Outbreak TTS时, 我就是靠这个工具得以提前12小时看到了不同任务的序言CG.</p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Menu.Main.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Menu.Main.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="RAD Main Menu"></p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul><li>RAD Video Tools    由RAD Game Tools开发的专有视频处理工具, 可处理Bink及Smack格式视频    下载地址: <a href="http://www.radgametools.com/bnkdown.htm">Bink Downloads</a></li></ul><h4 id="使用RAD-Video-Tools解包"><a href="#使用RAD-Video-Tools解包" class="headerlink" title="使用RAD Video Tools解包"></a>使用RAD Video Tools解包</h4><p>&emsp;&emsp;RAD Video Tools用来解包相当简单, 一般来说只需打开RAD VT, 在选中想解包的CG后点击”Convert to……”按钮, 最后选择输出格式、确定输出路径就好了. 如果需要直接转为视频则只能输出avi, 编码也只能选未压缩. 不过众所周知, 未压缩的avi视频相当大, 如果您只是需要分享则最好输出exe, 输出文件大小和源文件几乎一致. (我猜是把一个播放器和bik打包在一起了)</p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Menu.Convert.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Menu.Convert.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="RAD Convert Menu"></p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Menu.SetCodec.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Menu.SetCodec.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="RAD Convert Select Codec"></p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Convert.Processing.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Convert.Processing.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="RAD Converting"></p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Convert.Done.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Convert.Done.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="RAD Converted"></p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Menu.AdvancedPlay.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Menu.AdvancedPlay.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="RAD Advanced Play Menu"></p><p>&emsp;&emsp;你问能不能用现代的编码器? 醒醒, Bink 1不支持外部编码器, 而现代的Bink 2 SDK是付费、商业用的……</p><p>&emsp;&emsp;”那其它内置的编码器不能用🐎?” 在, 看看关于? 上世纪的编码器您敢用? 即便使用, 输出的文件也会有一车问题. 是FFmpeg重新编码不香吗? 但这个我就不赘述了.</p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.GrandpaCodec.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.GrandpaCodec.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="RAD Grandpa Codec"></p><p>&emsp;&emsp;不过R2SI 2020的序言CGI是个例外, 即便输出raw avi也会出现诡异的时间轴和采样问题. 但将每一帧输出为图片则没有问题……</p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/R6S.CGI.y4s4_overview.RadTransGlitch.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/R6S.CGI.y4s4_overview.RadTransGlitch.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="RAD Weird Ouput"></p><p>&emsp;&emsp;鬼知道未来还会不会出现这种问题, 而且方便传播的视频谁不爱呢? 因此我认为需要一个备用方案, 所以该FFmpeg登场了.</p><h4 id="令RAD-VT输出每一帧为图片-并使用FFmpeg将图片编码为视频"><a href="#令RAD-VT输出每一帧为图片-并使用FFmpeg将图片编码为视频" class="headerlink" title="令RAD VT输出每一帧为图片, 并使用FFmpeg将图片编码为视频"></a>令RAD VT输出每一帧为图片, 并使用FFmpeg将图片编码为视频</h4><p>&emsp;&emsp;(我没有空间和时间再演示一次R2SI 2020的CGI解包打包了, 找了个Y5干员bundle解锁CGI权当示例, 反正操作完全一致</p><p>&emsp;&emsp;首先通过RAD VT查看.bik视频的帧率(File Info), 要是和整数很接近的小数的话四舍五入到整数并记住它. (这样的帧数其实是个历史包袱, 感兴趣的话可以观看<a href="https://www.bilibili.com/video/BV1kE411c7yZ">影视飓风的视频</a>)</p><p>&emsp;&emsp;接下来使用RAD VT的转换功能, 设置RAD VT的输出为png以保持无损, 选好输出目录与输出名字, 开始转换. 视频的每一帧将自动输出为png图片, 并在文件名最后自动加上帧数号(帧数号含前缀0).</p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Output.Pics.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/RADVT.Output.Pics.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="RAD Pic Output List"></p><p>&emsp;&emsp;假定你已经配置好了FFmpeg, 可以使用终端/命令行调用. 我们只需要调用ffmpeg/ffmpeg.exe</p><p>&emsp;&emsp;打开终端/命令行, 执行以下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(ffmpeg程序路径) -framerate (源文件帧率) -i (图片位置)/(输出文件名)%(最大帧数位数)d.png -c:v libx264 -preset veryslow -crf 17 -tune film -r (源文件帧率) (输出路径)/(输出文件名, 含扩展名)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>-framerate指定了输入文件被看待的帧率, -i指定了输入文件, -c:v指定了输出视频的编码器, -crf指定了输出质量, -r指定了输出文件的帧率.</p></li><li><p>文件名中的通配符与C/C++中scanf函数的参数一致.</p></li><li><p>如有Intel/Nvidia/AMD的可编码视频的GPU, 可将编码器换为h264_qsv/h264_nvenc/h264_amf, 相应地输出文件质量会有所下降.</p></li><li><p>-preset 为预设, veryfast/fast牺牲质量换取时间, slower/veryslow牺牲时间换取质量. 时间越短, 输出文件大小越大, 质量越差, 反之亦然. 需要其它预设请自行查阅FFmpeg手册.</p></li><li><p>-crf 取值0-51, 17/18为视觉无损压缩. 如果希望降低输出大小可适当增加, 当然质量会相应地有所下降.</p></li><li><p>-tune 可针对场景调节编码, 优化图像质量. 由于拆迁所有CGI全为写实渲染, 建议选择film.</p></li><li><p>以上使用了目前最流行的H.264编码, 需要H.265将上述编码器名称中的264换为265即可. 其它编码如VP9, AV1请自行探索. 注意, 不是所有编码器都支持以上微调选项!</p></li><li><p>建议输出mp4/flv/mkv, 方便后期添加声音.</p></li><li><p>根据实际情况替换括号(包括括号本身)的内容.</p></li></ul><p>&emsp;&emsp;以我举的样例为例, 命令为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./ffmpeg.exe -framerate 30 -i ./tutor/y5s1_opsunlock_bundle_dynamic%3d.png -c:v libx264 -crf 17 -r 30 ./y5s1_opsunlock_bundle_dynamic.mp4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里是运行结果:</p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/FFmpeg.Encoding.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/FFmpeg.Encoding.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="FFmpeg Encoding"></p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/FFmpeg.Done.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/FFmpeg.Done.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="FFmpeg Done"></p><p>&emsp;&emsp;如果操作过程中不出错, 成品应该会出现在你指定的位置.</p><p>&emsp;&emsp;下面便是是成品. 注意, 为了能塞进CDN, 我把成品转为了gif并降低了分辨率和帧率.</p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/R6S.CGI.y5s1_opsunlock_bundle_dynamic.360P10FPS.gif" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/R6S.CGI.y5s1_opsunlock_bundle_dynamic.360P10FPS.gif" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="y5s1_opsunlock_bundle_dynamic"></p><p>&emsp;&emsp;如需添加音轨, 再在第一个-i后添加另一个-i开关并输入音频, 接着对音频使用copy编码就行了. 其它高级玩法请自行查阅FFmpeg手册.</p><h3 id="声音"><a href="#声音" class="headerlink" title="声音"></a>声音</h3><p>&emsp;&emsp;在Y0至Y5S2钢铁洪流赛季, 拆迁的声音使用了Audiokinect Wwise套件, 并被打包在拆迁根目录下的sounddata目录的子目录中, 扩展名为.pck</p><p>&emsp;&emsp;从Y5S3暗影之遗开始, 育碧将声音包改用AnvilNext封包, 针对pck的方法自此开始不再适用. 目前已有对新格式文件的研究, 将来将会持续跟进.</p><h4 id="文件信息-1"><a href="#文件信息-1" class="headerlink" title="文件信息"></a>文件信息</h4><p>&emsp;&emsp;.pck文件有多种命名方式:</p><ul><li>sound_sfx              存储各种音效, 大多为枪声/物件声.</li><li>sound_sfx_bootstrap    存储赛季/活动音乐(主题曲)、地图音乐与部分UI/氛围音效.</li><li>sound_sfx_playgo       存储情境、情境/干员CGI音乐与部分UI/氛围音效</li><li>sound_sfx_maps         存储地图环境音与地图内物件声音.</li><li>sound_sfx_events       存储活动所使用的特殊音效.</li><li>sound_sfx_cgi          存储CGI使用的音乐.</li><li>sound_(语言缩写)        存储对应语言的语音.</li><li>及以上格式的组合, 等.</li></ul><p>&emsp;&emsp;这里是Y5S1.0文件列表示例:</p><p><img src="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/R6S.Y5S1_0.sounddata.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/r6s-datamine-guide/R6S.Y5S1_0.sounddata.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="Y5S1.0 Sounddata"></p><p>&emsp;&emsp;将.pck拆开后会发现子文件有四种扩展名. 这里给出对应编码和主要存储内容:</p><ul><li>.wwise    为Wwise Vorbis RIFF编码的有损声音文件, 几乎什么都存储(例如赛季主题曲, 地图主题音乐, 菜单BGM、按钮音效)</li><li>.lwav     为Wwise IMA ADPCM编码的无损声音文件, 存储部分地图/物件音效</li><li>.at3      为Wwise PCM编码的无损声音文件, 寥寥无几</li><li>.pnk      为包含文件内部名称及部分声音子文件的包  <del>禁止套娃</del></li></ul><p>&emsp;&emsp;在Y4的某次更新中, .pnk文件不再存储声音的内部名称, 使用现有工具/脚本解当前版本游戏的包, 所得的对应声音的文件名将会变为相应文件在原包中的16位offset地址!</p><h4 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h4><p><strong><em>以下内容较为硬核, 不建议普通玩家轻易尝试. 而且由于我时间不足, 以下教程仅为粗略指导, 若有无法复现情况的请认真阅读相应工具的帮助文档, 进行Debug, 并前往相应工具来源论坛求助. 如果未来有时间, 我会对下述内容进行对普通人更友好的完善.</em></strong></p><p>&emsp;&emsp;Wwise在游戏工业界已经使用多年, 即便官方从未支持解包, 民间工具也已相当完善. 这里列举我所使用的工具.</p><p>&emsp;&emsp;下述工具均已上传至我的下载站. <a href="https://dl.infi.wang/R6SFiles/Tools/">infiDownloadSite/R6SFiles/Tools</a></p><h5 id="手动工具"><a href="#手动工具" class="headerlink" title="手动工具"></a>手动工具</h5><ul><li>QuickBMS  通用文件处理引擎, 为一脚本解释器. 由Luigi Auriemma开发, 开源, 协议未知.  主页: <a href="https://aluigi.altervista.org/quickbms.htm">Luigi Auriemma QuickBMS</a></li><li>ww2ogg  Wwise Vorbis RIFF/RIFX编码声音文件转ogg Vorbis声音文件工具, 用于转换.wwise文件.  由hcs(Adam Gashlin)开发, 开源, 使用BSD Clause-3协议.  GitHub仓库: <a href="https://github.com/hcs64/ww2ogg">hcs64/ww2ogg</a></li><li>wwise_ima_adpcm  Wwise IMA ADPCM编码声音文件与PCM声音文件互转工具, 用于转换.lwav文件.  由Zwagoth开发, 未找到原始下载源.</li><li>revorb  ogg Vorbis音频granule_position修复工具, 用于修复ww2ogg输出.  由Yirkha(Jiri Hruska)开发, 开源, 使用MIT协议.  原发布贴: <a href="https://web.archive.org/web/20150619030401/https://hydrogenaud.io/forums/lofiversion/index.php/t64328.html">Can’t play vorbis</a>  源代码: <a href="https://web.archive.org/web/20150619030401/http://yirkha.fud.cz/progs/foobar2000/revorb.cpp">revorb.cpp</a></li><li>func_getTYPE.bms  使用启发式算法确定文件类型的QBMS脚本, 是多个QBMS脚本的依赖, 作者为XeNTaX论坛的AlphaTwentyThree.</li><li>pck_AKPK_extractor.bms  用于解包.pck文件的QBMS脚本, 作者同为XeNTaX论坛的AlphaTwentyThree.</li><li>bnk_extractor.bms  用于解包.bnk文件的QBMS脚本, 作者依然是XeNTaX论坛的AlphaTwentyThree.</li><li>wwise_pcm_decoder.bms  Wwise PCM编码声音文件转PCM声音文件QBMS脚本, 用于转换.at3文件.  作者未知.</li></ul><h5 id="自动工具"><a href="#自动工具" class="headerlink" title="自动工具"></a>自动工具</h5><p><strong><em>One tool to Rule’em all</em></strong></p><ul><li>Tom Clancy’s Rainbow Six Siege Sound Extractor  R6S声音文件解包工具, 作者为XeNTaX论坛的FatalBulletHit.  开源, 协议未知. 本质为Windows CMD脚本与Powershell脚本, 将上述手动工具解包过程自动化.  原发布贴: <a href="http://forum.xentax.com/viewtopic.php?p=140570#p140570">Tom Clancy’s Rainbow Six Siege Sound Extractor</a></li></ul><h5 id="使用手动工具解包"><a href="#使用手动工具解包" class="headerlink" title="使用手动工具解包"></a>使用手动工具解包</h5><p>&emsp;&emsp;大多数工具按照相应–help和文档进行操作即可.</p><h5 id="使用自动工具解包"><a href="#使用自动工具解包" class="headerlink" title="使用自动工具解包"></a>使用自动工具解包</h5><p>&emsp;&emsp;从源站下载bat, 执行, 完结撒花(</p><p>&emsp;&emsp;有以下几个坑:</p><ul><li>Powershell版本不应低于Powershell 4</li><li>bat脚本其实只是核心Powershell脚本的Bootstrapper, 建议在实际使用时直接从Powershell启动ps1脚本, 否则容易出现像是文件解不出来、解出AudioKinect文件不转换甚至都解好转换完毕了还能删歪来的迷惑行为.</li><li>工具默认从注册表读取Uplay版本的安装地址. 如果你用的是Steam / Origin / 其它平台(包括破解版 / 备份), 记得修改脚本中的地址定义变量. 注意符号转义行为!</li><li>脚本默认使用Powershell的Test-Connection函数对<a href="http://www.google.com/">www.google.com</a> 测试网络连通性, 若不通脚本则会罢工, 而且在国内即便开了小飞机也有可能出现奇妙的问题. 建议全文搜索, 将 <a href="http://www.google.com/">www.google.com</a> 替换成国内可ping地址. 我个人使用的是 <a href="http://www.miui.com/">www.miui.com</a> . 当然, 要是您的网络无法下载脚本所需的相应手动工具, 自然也无法解包.</li><li>建议打开-Debug开关, 时刻准备好debug.</li><li>只要你在工具内选择解相应格式的包, 所有对应格式的包都会被解包、转换. 对于pck原包来说, 其实工具只是识别并解”游戏文件夹/sounddata/pc”内的所有pck包文件. 如果您只想解某一特定的包, 可以将不想要的文件剪切走; 或者干脆新建个文件结构和游戏目录一致的”假”文件夹, 把想解的包粘贴进去, 再把假游戏文件夹喂给脚本就行了.</li><li>原文件内小文件众多, IOPS压力会很大, 解包输出也大的离谱. 建议准备好声音文件大小两倍左右的空间, 放在SSD上跑. 个人解Y4S4时程序在eMMC USB盘上跑了15个小时, 人都等傻了.</li></ul><h2 id="Happy-Hacking"><a href="#Happy-Hacking" class="headerlink" title="Happy Hacking!"></a>Happy Hacking!</h2>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 中文 </category>
          
          <category> 游戏 </category>
          
          <category> 彩虹六号 </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 彩虹六号 </tag>
            
            <tag> 逆向 </tag>
            
            <tag> 教程 </tag>
            
            <tag> RAD Video Tools </tag>
            
            <tag> QuickBMS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>他与OI</title>
      <link href="posts/2019/12/his-oi-story.zh/"/>
      <url>posts/2019/12/his-oi-story.zh/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.infi.wang/pic/blog/his-oi-story/infiWangAndSF.jpg" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/his-oi-story/infiWangAndSF.jpg" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif"></p><blockquote><p>&emsp;&emsp;西西佛斯因恼怒了神祇, 被罚以一项永无止歇的苦刑: 将一块大石头从奥林帕斯山下推到山上. 但由于诅咒的力量, 巨石抵达山顶的刹那, 就会自动滚落到山下, 周而复始. 西西佛斯永远没有完成使命的一天, 永远重复同样劳苦无望的命运……<br>&emsp;&emsp;然而有一天, 西西佛斯在搬运巨石的途中忽然觉得自己搬动巨石的每个动作都那么美: 他专注地观察着自己全力以赴的每个当下, 有了一种幸福感; 他全心享受这份苦役, 不再抱怨焦虑. 奇妙的事发生了: 诅咒竟然在这一刹那解除, 巨石不再滚回山下, 西西佛斯从永无休止的苦役中重获自由.</p></blockquote><span id="more"></span><h2 id="这是他的故事"><a href="#这是他的故事" class="headerlink" title="这是他的故事"></a>这是他的故事</h2><p>&emsp;&emsp;不知道是什么时候, 父亲在一个傍晚给他展示了一台笔记本电脑. 小孩子生性爱玩, 乱按之下不小心把电脑的光驱弹出了, 引得父亲一阵大笑.</p><p>&emsp;&emsp;6岁那年, 他在父亲的书柜上看到了一本Delphi编程教程, 拿下来开始瞎读. 父亲见状打开了电脑, Delphi的界面映入眼中. 他不懂什么是编程, 但觉得控件拖拽后就成了电脑里的界面是很奇妙的事. “你拖了个计时器, 想编个时钟吗?” 父亲调侃道. 原来这就是编程? 他想着.</p><p>&emsp;&emsp;小学时他用着Word自带的VB不时在计算机课上瞎搞, 意外发现了变量类型间转换的奇妙关系; 靠着Minecraft, 他见识到了mod与底层JVM的神奇. 彼时VB.Net带来的巨大语法变化让他连面向谷歌编程都无所适从, 也许是时候学新语言了. C++? 听说大学都不一定学的通. 在书店乱逛时, 一本《精通C#》让他喜出望外, 打开了.net的新世界.</p><p>&emsp;&emsp;父亲换了工作, 在一个军工机构下属单位. 父亲带上他去公司玩, 楼下的火车呜呜地飞驰. 中午, 他们一起出去吃饭. 高新区很冷清, 但这条街道却不一样, 路上全是中学生. 坐在自行车上, 店铺招牌一个个地从眼前飘过. 突然, 招牌断开了, 取而代之的是围墙上一个个的三环图标. “这里是SF, 现在我们省最厉害的高中! “ 父亲说着, 满是期冀.</p><p>&emsp;&emsp;时光眨眼间飞逝, 他小学毕业了, 小升初考上了全省最优秀的两所初中——一二一中学和建设路中学. 父亲认为建设路中学会更好, 因为高中升学率更高; 但他在一二一中学的考试中得分更高, 所以他还是去了一二一中学.</p><p>&emsp;&emsp;他认识了Mouered, 最开始只是因为Minecraft. Mouered喜欢航模, 他喜欢计算机, 未尝想Mouered知道他的兴趣后找他借了一本VB编程教程. Mouered写了个聊天软件给班上用, 信息老师见了大为赞叹. 他想写个安装器, 哪知道自己连开源压缩库都用不通; 他想用C#写个能与Mouered的程序兼容的客户端, 甚至还能用QQ做广域网通信, 最终却只写了个主界面就懒病发作. 但他却想开个大公司, 幻想着超越巨硬和谷歌……</p><p>&emsp;&emsp;每天早上, 他都会骑自行车上学. 寒风瑟瑟, 路边树上的梧桐叶所剩无几. 初三即将升学, 但他的成绩却依然不理想. 父母曾专门找他, 用上期末的分数做了个换算, 数落着连No8HS和No10HS都考不上. 他不满地争辩: 一二一中学的题目很难, 他腿受伤体育低了20分…… 但在父母看来都是狡辩. 他压力倍增, 上学路上只想着更快一点, 在那霓虹灯关灯前超过它, 否则就考不上SF…… 他知道这是幻想, 物质世界是永远不会随主观臆想改变的, 但又有何用?</p><p>&emsp;&emsp;梧桐树又长满了绿叶, 天气渐渐炎热. 中考到了. 考完的那天晚上, 狂风大作, 雨水倾泻着打响了屋檐与树叶, 10多个响雷打在了他家附近. 他听着、看着, 想笑又不知道为什么.</p><p>&emsp;&emsp;他交了SF的志愿单, 想象着和父亲一起上学. 父母以求稳为由, 逼迫他把志愿改成No1HS.</p><p>&emsp;&emsp;他已经不记得那几天是怎么过去的了. 永恒的夏日, 无尽的阳炎, 只有一台树莓派和几块开发板陪他度日. 只要父亲一回家, 他们便争吵着志愿的事, 却都以填都填了为由被搪塞了回去.</p><p>&emsp;&emsp;出分了, 575分. 他刚想跳起来, 却还没使力就绝望地掉了下去.</p><p>&emsp;&emsp;这是一个即便在一二一中学这样群英荟萃的地方都亮眼的分数.</p><p>&emsp;&emsp;Mouered去了SF, 他也本因这样, 但没有; SF开始了YNOI的复兴, Mouered也参加了; 他也想去, 但No1HS对OI根本不上心; 他开始幻想着时光能倒流. 但不可能.</p><p>&emsp;&emsp;17年, 父母想方设法让他进了SF, 但不久他就倒在了抑郁症下.</p><p>&emsp;&emsp;他开始了漫长的休学. 又是一年盛夏, NOIP2017就快到了. 他本想找HYH老师请LYY带他, 但他的心境甚至连游戏都打不动. 云竞赛? 也好. 他开始在Bihu上看OIer们的交流, 混进OI群静静听讨论. 他开始慢慢学习编译装载原理, 向高深的C++进发.</p><p>&emsp;&emsp;红嘴鸥飞临, 又是冬天了. 他开始迷上了理论计算机与图形学. 和沙雕网友打游戏虽然能让他开心起来了, 但不论如何终要面临复学. 5月, 初夏, 他和母亲去了成都, 见了OIer YY和YY的教练. 直至现在, 他还记得那句”伙子加油! “; 9月, 他回到了学校, 不过是SF.cg. 也好, 他想. “但是OI呢?”</p><p>&emsp;&emsp;”现在有一个竞赛, 感兴趣的可以过来看看. “ “是NOIP吗? “ “对的. “ 就这样, ZSH成了他的教练. Mouered开始调侃他是不是圆了梦.</p><p>&emsp;&emsp;我想, 是的. 不论是学校亦或是OI. 毕竟, “他”就是我, infiWang. 回望过去, 中考填志愿那天在教室门口怅然若失的我哪能想到自己会走上一条这样的道路. 翻开初中毕业纪念册, 自己所留下的那句”做最好的自己”依然醒目.</p><p>&emsp;&emsp;是的, 我OI很菜. NOIP18丢了100多分, 今年CSP19更是连100都没上. 也许着一切只是我对SF的情结? 又或就如织梦岛中风之鱼的一场梦? 这不重要. 重要的是, 我为了自己奋斗过. 虽然我NOIP2018分数不占优势, 还是在NOI19-YN省选考到了全省第五; 我用OI克服了抑郁和社恐, 在这奇幻的经历中认识了YZH、GLY、HWH、YY、WilliamGong、XWY、SheKong、JzJiang、neilkleist、yussgrw、范滇东、泠妄、悠悠、一个昵称(WYX)、wyqwq、QiFeng众多YN及省外的OIer, 而且恐怕是SF理社的第一名cg社员; 在班上, 我们也有着LJC、LMJ、ZSM等众多各学科竞赛选手互相支持; 在CS方面, 我学到了很多算法及算法的思想, 对计算机的认识又更深了……</p><p>&emsp;&emsp;就如ZCY所说: “我们喜欢的可能不是OI, 而是OI这件事情本身, 而是和一群志同道合的人一起, 做些即使拿自己的未来做赌注也喜欢, 也要去做的事情.” 所以, 对事物追求的经历与其中奋斗的过程才是更为重要的吧.</p><p>&emsp;&emsp;一如校训中的刚毅艰卓, 抑或是熊庆来先生留下的”行远路, 做大事”.</p><h2 id="谢谢你听完我的故事"><a href="#谢谢你听完我的故事" class="headerlink" title="谢谢你听完我的故事"></a>谢谢你听完我的故事</h2><p>题图摄于和成国际. 拍完这张照片后我回学校溜达了一阵</p><p>另外感谢Mouered, ZXY, ZSH, LYY, WBY.</p>]]></content>
      
      
      <categories>
          
          <category> infi </category>
          
          <category> OI </category>
          
          <category> 中文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> infi </tag>
            
            <tag> 随笔 </tag>
            
            <tag> OI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018 Day2T1 题解</title>
      <link href="posts/2019/11/noip2018-d2t1-solution.zh/"/>
      <url>posts/2019/11/noip2018-d2t1-solution.zh/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.infi.wang/pic/blog/noip2018-d2t1-solution/brutalForceTLE.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/noip2018-d2t1-solution/brutalForceTLE.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="initalResult"></p><p>去年考场上本题考虑过多, 喜提60变20、1=变2=、省队变差8分, 草(砸电脑.gif</p><hr><p><strong>本题解几乎全为代码, 请静下心阅读. 我相信我的代码的可读性还是很高的.</strong></p><span id="more"></span><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://cdn.infi.wang/pic/blog/noip2018-d2t1-solution/NOIP2018.D2T1.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/noip2018-d2t1-solution/NOIP2018.D2T1.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="NOIP2018.D2T1"></p><p><img src="https://cdn.infi.wang/pic/blog/noip2018-d2t1-solution/NOIP2018.D2T1.Datarange.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/noip2018-d2t1-solution/NOIP2018.D2T1.Datarange.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="Datarange"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;回到正题. 首先观察数据. n = 5000, 所以暴力就好了. 我在考场上用邻接矩阵都过了树的subtask.</p><p>&emsp;&emsp;现在讨论各个subtask的情况.</p><h3 id="n-m-1"><a href="#n-m-1" class="headerlink" title="n = m - 1"></a>n = m - 1</h3><p>&emsp;&emsp;明显, 此时的图为一棵树. 只需以出边到达点字典序从小到大进行一次不回溯的DFS(树生成), 再判断生成树的字典序即可; 复杂度$\Theta \left ( N \right )$.</p><p>&emsp;&emsp;以下为本人去年此subtask的去锅代码.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,current;</span><br><span class="line"><span class="keyword">bool</span> isFinal;</span><br><span class="line"><span class="keyword">int</span> minimalSet[<span class="number">1</span> + maxN];</span><br><span class="line"><span class="keyword">bool</span> isCityVisited[<span class="number">1</span> + maxN];</span><br><span class="line"><span class="keyword">bool</span> roadIndex[<span class="number">1</span> + maxN][<span class="number">1</span> + maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(<span class="keyword">int</span> nowCity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isFinal)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">current++;</span><br><span class="line">minimalSet[current] = nowCity;</span><br><span class="line">isCityVisited[nowCity] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(current == n)</span><br><span class="line">&#123;</span><br><span class="line">minimalSet[<span class="number">0</span>] = nowCity;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%i &quot;</span>,minimalSet[i]);</span><br><span class="line">&#125;</span><br><span class="line">isFinal = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isCityVisited[i] == <span class="literal">false</span></span><br><span class="line">&amp;&amp;(roadIndex[nowCity][i] || roadIndex[i][nowCity]))</span><br><span class="line">&#123;</span><br><span class="line">travel(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%i %i&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">roadIndex[u][v] = <span class="literal">true</span>;</span><br><span class="line">roadIndex[v][u] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">travel(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="n-m"><a href="#n-m" class="headerlink" title="n = m"></a>n = m</h3><p>&emsp;&emsp;相应地, 这种情况下的图为有且只有一条环的图.</p><p>&emsp;&emsp;去年看到这就放弃了, 毕竟当时连存图都是凭印象瞎搞的. 当然, 现在看来无非两种方式: 找边, 找环. 这里从简(其实还是不会), 只讨论暴力断边的方案.</p><p>&emsp;&emsp;这样一张图(基环树/图)有这样的性质: 断环上的任意一条边, 图就变成一棵树. 那么就有以下暴力断开每一条边再进行树生成并判断字典序的代码.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="keyword">bool</span> w;</span><br><span class="line"></span><br><span class="line">Edge(<span class="keyword">int</span> U = <span class="number">0</span>, <span class="keyword">int</span> V = <span class="number">0</span>, <span class="keyword">bool</span> W = <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*<span class="keyword">this</span>).u = U, (*<span class="keyword">this</span>).v = V, (*<span class="keyword">this</span>).w = W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::swap((*<span class="keyword">this</span>).u, (*<span class="keyword">this</span>).v);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Edge <span class="title">getReversed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Edge((*<span class="keyword">this</span>).v, (*<span class="keyword">this</span>).u, (*<span class="keyword">this</span>).w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Edge <span class="keyword">operator</span> = (<span class="keyword">const</span> Edge&amp; inEdge)</span><br><span class="line">&#123;</span><br><span class="line">(*<span class="keyword">this</span>).u = inEdge.u, (*<span class="keyword">this</span>).v = inEdge.v, (*<span class="keyword">this</span>).w = inEdge.w;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">emptyEdge;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge E, Edge e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> E.v &lt; e.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* ori, <span class="keyword">int</span>* des)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) des[i] = ori[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">bool</span> stat, <span class="keyword">bool</span>* des)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) des[i] = stat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isMinDic</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* dicOri, <span class="keyword">int</span>* dicCmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dicCmp[i] != dicOri[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dicCmp[i] &gt; dicOri[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(dicCmp[i] &lt; dicOri[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">bool</span> w, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;* graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = graph[u].begin(); it != graph[u].end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((*it).v == v)</span><br><span class="line">&#123;</span><br><span class="line">(*it).w = w;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span>&amp; depth, <span class="keyword">bool</span>* isVisited, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;* graph, <span class="keyword">int</span>* dic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">isVisited[now] = <span class="literal">true</span>;</span><br><span class="line">dic[depth++] = now;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = graph[now].begin(); it != graph[now].end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!isVisited[(*it).v] &amp;&amp; (*it).w)</span><br><span class="line">DFS((*it).v, depth, isVisited, graph, dic);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">subtask</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;* graph, <span class="keyword">bool</span>* isVisited, <span class="keyword">int</span>* dic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = graph[k].begin(); it != graph[k].end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">(*it).w = <span class="literal">false</span><span class="comment">/*, setEdge((*it).v, (*it).u, false, graph)*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tDic[<span class="number">1</span> + n]; tDic[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;tDic[i] = <span class="number">5000</span> + <span class="number">1</span>; isVisited[i] = <span class="literal">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">DFS(<span class="number">1</span>, depth, isVisited, graph, tDic);</span><br><span class="line"><span class="keyword">if</span>(isMinDic(n, dic, tDic)) copy(n, tDic, dic);</span><br><span class="line"></span><br><span class="line">(*it).w = <span class="literal">true</span><span class="comment">/*, setEdge((*it).v, (*it).u, true, graph)*/</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; graph[<span class="number">1</span> + n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%i %i&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">graph[u].push_back(Edge(u, v));</span><br><span class="line">graph[v].push_back(Edge(v, u));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::sort(graph[i].begin(), graph[i].end(), cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dic[<span class="number">1</span> + n]; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;dic[i] = <span class="number">5000</span> + <span class="number">1</span>;&#125; dic[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> isVisited[<span class="number">1</span> + n]; <span class="built_in">memset</span>(isVisited, <span class="literal">false</span>, <span class="keyword">sizeof</span>(isVisited));</span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">n != m ? DFS(<span class="number">1</span>, depth, isVisited, graph, dic)</span><br><span class="line">   : subtask(n, graph, isVisited, dic);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%i &quot;</span>, dic[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.infi.wang/pic/blog/noip2018-d2t1-solution/brutalForceTLE.png" class="lazyload placeholder" data-srcset="https://cdn.infi.wang/pic/blog/noip2018-d2t1-solution/brutalForceTLE.png" srcset="http://cdn.infi.wang/pic/blog/assets/loading.gif" alt="TLE"></p><p>&emsp;&emsp;我交了, 吸氧了, 多50ms T了, 那咋办嘛 QAQ</p><p>&emsp;&emsp;很明显, 这个简单暴力方法的复杂度为$\Theta\left(N^{2}\right)$, 所以T了也不奇怪.</p><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>&emsp;&emsp;相应地, 这时就需要剪枝了.</p><p>&emsp;&emsp;这里只讲最优化剪枝. 当当前搜索所得序列劣于已得最佳序列时就可选择剪枝. 修改上述程序, 最终得到以下代码, 复杂度$\Omega\left(n\right)$, $O\left(N^{2}\right)$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="keyword">bool</span> w;</span><br><span class="line"></span><br><span class="line">Edge(<span class="keyword">int</span> U = <span class="number">0</span>, <span class="keyword">int</span> V = <span class="number">0</span>, <span class="keyword">bool</span> W = <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*<span class="keyword">this</span>).u = U, (*<span class="keyword">this</span>).v = V, (*<span class="keyword">this</span>).w = W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::swap((*<span class="keyword">this</span>).u, (*<span class="keyword">this</span>).v);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Edge <span class="title">getReversed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Edge((*<span class="keyword">this</span>).v, (*<span class="keyword">this</span>).u, (*<span class="keyword">this</span>).w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Edge <span class="keyword">operator</span> = (<span class="keyword">const</span> Edge&amp; inEdge)</span><br><span class="line">&#123;</span><br><span class="line">(*<span class="keyword">this</span>).u = inEdge.u, (*<span class="keyword">this</span>).v = inEdge.v, (*<span class="keyword">this</span>).w = inEdge.w;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">emptyEdge;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge E, Edge e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> E.v &lt; e.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* ori, <span class="keyword">int</span>* des)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) des[i] = ori[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">bool</span> stat, <span class="keyword">bool</span>* des)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) des[i] = stat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isMinDic</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* dicOri, <span class="keyword">int</span>* dicCmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dicCmp[i] != dicOri[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dicCmp[i] &gt; dicOri[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(dicCmp[i] &lt; dicOri[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">bool</span> w, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;* graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = graph[u].begin(); it != graph[u].end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((*it).v == v)</span><br><span class="line">&#123;</span><br><span class="line">(*it).w = w;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span>&amp; depth, <span class="keyword">bool</span>* isVisited, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;* graph, <span class="keyword">int</span>* dic, <span class="keyword">int</span>* cmpDic, <span class="keyword">bool</span>&amp; wasEqual, <span class="keyword">bool</span>&amp; isBestSolution, <span class="keyword">bool</span>&amp; notBestSolution)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(notBestSolution) <span class="keyword">return</span>;</span><br><span class="line">isVisited[now] = <span class="literal">true</span>;</span><br><span class="line">dic[depth] = now;</span><br><span class="line"><span class="keyword">if</span>(wasEqual &amp;&amp; !isBestSolution)</span><br><span class="line">&#123;</span><br><span class="line">dic[depth] != cmpDic[depth] ? (dic[depth] &lt; cmpDic[depth] ? isBestSolution = <span class="literal">true</span> : <span class="literal">false</span>),</span><br><span class="line">  (dic[depth] &gt; cmpDic[depth] ? notBestSolution = <span class="literal">true</span> : <span class="literal">false</span>),</span><br><span class="line">  wasEqual = <span class="literal">false</span></span><br><span class="line">: wasEqual = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">depth++;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = graph[now].begin(); it != graph[now].end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!isVisited[(*it).v] &amp;&amp; (*it).w)</span><br><span class="line">DFS((*it).v, depth, isVisited, graph, dic, cmpDic, wasEqual, isBestSolution, notBestSolution);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">subtask</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>&amp; depth, <span class="keyword">bool</span>* isVisited, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;* graph, <span class="keyword">int</span>* dic, <span class="keyword">int</span>* resultDic, <span class="keyword">bool</span>&amp; wasEqual, <span class="keyword">bool</span>&amp; isBestSolution, <span class="keyword">bool</span>&amp; notBestSolution)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = graph[k].begin(); it != graph[k].end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">(*it).w = <span class="literal">false</span><span class="comment">/*, setEdge((*it).v, (*it).u, false, graph)*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tDic[<span class="number">1</span> + n];</span><br><span class="line">tDic[<span class="number">0</span>] = <span class="number">0</span>, depth = <span class="number">1</span>, wasEqual = <span class="literal">true</span>, isBestSolution = <span class="literal">false</span>, notBestSolution = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;tDic[i] = <span class="number">5000</span> + <span class="number">1</span>; isVisited[i] = <span class="literal">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">DFS(<span class="number">1</span>, depth, isVisited, graph, tDic, resultDic, wasEqual, isBestSolution, notBestSolution);</span><br><span class="line"><span class="keyword">if</span>(isBestSolution) copy(n, tDic, resultDic);</span><br><span class="line"></span><br><span class="line">(*it).w = <span class="literal">true</span><span class="comment">/*, setEdge((*it).v, (*it).u, true, graph)*/</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; graph[<span class="number">1</span> + n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%i %i&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">graph[u].push_back(Edge(u, v));</span><br><span class="line">graph[v].push_back(Edge(v, u));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::sort(graph[i].begin(), graph[i].end(), cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dic[<span class="number">1</span> + n]; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;dic[i] = <span class="number">5000</span> + <span class="number">1</span>;&#125; dic[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> isVisited[<span class="number">1</span> + n]; <span class="built_in">memset</span>(isVisited, <span class="literal">false</span>, <span class="keyword">sizeof</span>(isVisited));</span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">1</span>; <span class="keyword">bool</span> wasEqual = <span class="literal">true</span>, isBestSolution = <span class="literal">false</span>, notBestSolution = <span class="literal">false</span>;</span><br><span class="line">n != m ? DFS(<span class="number">1</span>, depth, isVisited, graph, dic, dic, wasEqual, isBestSolution, notBestSolution)</span><br><span class="line">   : subtask(n, depth, isVisited, graph, dic, dic, wasEqual, isBestSolution, notBestSolution);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%i &quot;</span>, dic[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI </tag>
            
            <tag> 算法 </tag>
            
            <tag> NOIP </tag>
            
            <tag> 搜索 </tag>
            
            <tag> DFS </tag>
            
            <tag> 剪枝 </tag>
            
            <tag> 生成树 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 树论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
